# ìŠ¤íŠ¸ë¦¼ì€ ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ë¼

---

ìŠ¤íŠ¸ë¦¼ì€ ë‹¤ëŸ‰ì˜ ë°ì´í„° ì²˜ë¦¬ ì‘ì—…ì„ ë•ê³ ì java 8 ì— ì¶”ê°€ë˜ì—ˆë‹¤.

## ğŸ’¡ìŠ¤íŠ¸ë¦¼ì˜ í•µì‹¬ ê°œë… 2ê°€ì§€

- ë°ì´í„° ì›ì†Œì˜ ë¬´í•œ ë˜ëŠ” ìœ í•œ ì‹œí€€ìŠ¤(ìˆœì„œìˆëŠ” ë‚˜ì—´)
- ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ ë¼ì¸ : ì›ì†Œë“¤ë¡œ ìˆ˜í–‰í•˜ëŠ” ì—°ì‚° ë‹¨ê³„

## ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ ë¼ì¸

- ì†ŒìŠ¤ ìŠ¤íŠ¸ë¦¼ - ì¤‘ê°„ ì—°ì‚°(ìŠ¤íŠ¸ë¦¼ì„ ë³€í™˜ ex: ì¡°ê±´, í•¨ìˆ˜ ì ìš©) - ì¢…ë‹¨ ì—°ì‚°
- ì§€ì—° í‰ê°€(lazy evaluation) : ì¢…ë‹¨ ì—°ì‚°ì´ ìˆ˜í–‰ë  ë•Œ í‰ê°€ëœë‹¤  - ì¢…ë‹¨ ì—°ì‚°ì´ ìˆ˜í–‰ë˜ì§€ ì•Šìœ¼ë©´ ì•„ë¬´ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.
- ì¼ë‹¨ í•œ ê°’ì„ ë‹¤ë¥¸ ê°’ì— ë§¤í•‘í•˜ê³  ë‚˜ë©´ ì›ë˜ì˜ ê°’ì€ ìƒëŠ” êµ¬ì¡°

## ì§€ì—° í‰ê°€(lazy evaluation)

ê·¸ë•Œ ê·¸ë•Œ ê°’ì„ í‰ê°€í•˜ì§€ ì•Šê³ , ì •ë§ ê²°ê³¼ê°’ì´ í•„ìš”í•œ ì‹œì ê¹Œì§€ í‰ê°€ë¥¼ ë¯¸ë£¨ëŠ” ê²ƒ

1. í•„ìš”í•  ë•Œë§Œ í‰ê°€ê°€ ë˜ë¯€ë¡œ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
2. ë¬´í•œ ìë£Œêµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ
3. ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ë°©ì§€ í•  ìˆ˜ ìˆë‹¤. ( ì»´íŒŒì¼ ì‹œ ì—ëŸ¬ë¥¼ ì²´í‚¹)
4. ì»´íŒŒì¼ëŸ¬ ìµœì í™” ê°€ëŠ¥

[ì§€ì—° í‰ê°€ ë§í¬](http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/)

```java
public static void main(String[] args) {
        List<Integer> numList = Arrays.asList(10, 20, 30, 40, 50, 60);
        System.out.println(numList.stream()
                .filter(num -> {
                    System.out.println("num < 50");
                    return num < 50;
                })
                .filter(num ->{
                    System.out.println("num < 30");
                    return num < 30;
                })
                .map(num ->{
                    System.out.println("num * 100");
                    return num * 100;
                })
                .collect(Collectors.toList())
        );
    }
```

```java
/**
num < 50
num < 30
num * 100
num < 50
num < 30
num * 100
num < 50
num < 30
num < 50
num < 30
num < 50
num < 50
[1000, 2000]
**/
```

## ë°˜ë³µë¬¸ì˜ ì¥ì (ì½”ë“œ ë¸”ëŸ­ ì‚¬ìš©ì˜ ì¥ì )

ìŠ¤íŠ¸ë¦¼ â†’ í•¨ìˆ˜ ê°ì²´ ì‚¬ìš©

ë°˜ë³µë¬¸ â†’ ì½”ë“œ ë¸”ë¡ ì‚¬ìš©

- ë²”ìœ„ ì•ˆì˜ ì§€ì—­ ë³€ìˆ˜ë¥¼ ì½ê³  ìˆ˜ì •ì´ ê°€ëŠ¥
- break, continueë¥¼ í™œìš©í•˜ì—¬ ë°˜ë³µë¬¸ì„ ì¢…ë£Œ, ë°˜ë³µì„ ë›°ì–´ ë„˜ì„ ìˆ˜ ìˆìŒ
- ë©”ì„œë“œ ì„ ì–¸ì— ì˜ˆì™¸ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•¨

## ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©ì„ ì¶”ì²œí•˜ëŠ” ê²½ìš°

- ì›ì†Œë“¤ì˜ ì‹œí€€ìŠ¤ë¥¼ ì¼ê´€ë˜ê²Œ ë³€í™˜í•˜ëŠ” ê²½ìš°
- ì›ì†Œë“¤ì˜ ì‹œí€€ìŠ¤ë¥¼ í•„í„°ë§í•˜ëŠ” ê²½ìš°
- ì›ì†Œë“¤ì˜ ì‹œí€€ìŠ¤ë¥¼ í•˜ë‚˜ì˜ ì—°ì‚°ì„ ì‚¬ìš©í•´ ê²°í•©í•˜ëŠ” ê²½ìš°
- ì›ì†Œë“¤ì˜ ì‹œí€€ìŠ¤ë¥¼ ì»¬ë ‰ì…˜ì— ëª¨ìœ¼ëŠ” ê²½ìš°(ê³µí†µëœ ì†ì„±ì„ ê¸°ì¤€ìœ¼ë¡œ)
- ì›ì†Œë“¤ì˜ ì‹œí€€ìŠ¤ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì›ì†Œë¥¼ ì°¾ëŠ” ê²½ìš°

---

## ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ì—¬ ê°€ë…ì„±ì´ ë†’ì•„ì§„ ì˜ˆì œ

```java
public static void main(String[] args) {
    File dectionary = new File(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    Map<String, Set<String>> groups = new HashMap<>();
    try (Scanner s = new Scanner(dectionary)) {
        while(s.hasNext()) {
            String word = s.next();
            groups.computeIfAbsent(alphabetize(word), 
                                   (unused) -> new TreeSet<>()).add(word);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    
    for(Set<String> group : groups.values()) {
        if(group.size() >= minGroupSize) {
            System.out.println(group.size() + ": " + group);
        }
    }
}

private static String alphabetize(String s) {
    char[] a = s.toCharArray();
    Arrays.sort(a);
    return new String(a);
}
```

- computeIfAbsent í•¨ìˆ˜:  ë§µ ì•ˆì— í‚¤ê°€ ìˆëŠ”ì§€ ì°¾ì€ í›„, ìˆìœ¼ë©´ ë‹¨ìˆœíˆ í‚¤ê°€ ë§¤í•‘ëœ ê°’ì„ ë°˜í™˜í•œë‹¤.

```java
public static void main(String[] args) throws IOException {
    File dectionary = new File(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    try(Stream<String> words = Files.lines(dectionary.toPath())) {
        words.collect(groupingBy(word -> alphabetize(word)))
            .values().stream()
            .filter(group -> group.size() >= minGroupSize)
            .forEach(group -> System.out.println(group.size() + ": " + group));
    }
}
```

ğŸ˜¡ìŠ¤íŠ¸ë¦¼ì„ ê³¼ìš©í•˜ë©´ í”„ë¡œê·¸ë¨ì„ ì½ê±°ë‚˜ ìœ ì§€ë³´ìˆ˜í•˜ëŠ” ê²ƒì´ ì–´ë ¤ì›Œ ì§„ë‹¤.

ğŸ’¡ëŒë‹¤ ì‚¬ìš©ì‹œ ë§¤ê°œë³€ìˆ˜ì˜ ë³€ìˆ˜ë¥¼ ì˜ ì§€ì–´ì•¼ ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ ë¼ì¸ì˜ ê°€ë…ì„±ì´ ì˜¬ë¼ê°„ë‹¤.

---

## ìŠ¤íŠ¸ë¦¼ê³¼ ë°˜ë³µ ì¤‘ ì–´ë–¤ ìª½ì„ ì¨ì•¼í• ì§€ ì•Œê¸° ì–´ë ¤ìš´ ê²½ìš°

ë°ì¹´ë¥´íŠ¸ ê³± : ê°€ëŠ¥í•œ ëª¨ë“  ì¡°í•©ì„ êµ¬í•˜ëŠ” ê²½ìš°

```java
private static List<Card> newDeck() {
    List<Card> result = new ArrayList<>();
    for(Suit suit : Suit.values()) 
        for(Rank rank : Rank.values())
            result.add(new Card(suit, rank));
    return result;
}
```

```java
private static List<Card> newDeck() {
    return Stream.of(Suit.values())
    .flatMap(suit -> Stream.of(Rank.values())
                      .map(rank -> new Card(suit, rank)))
    .collect(toList());
}
```

ë‘ ê°€ì§€ ê²½ìš°ê°€ ìˆëŠ”ë°, ì œ ê¸°ì¤€ ë°˜ë³µì„ í™œìš©í•œ ì½”ë“œê°€ ë” ê°€ë…ì„±ì´ ë†’ì•˜ìŠµë‹ˆë‹¤.

---

## ğŸ¤·â€â™€ï¸Streamê³¼ ë°˜ë³µì¤‘ ì–´ëŠ ìª½ì´ ë” ìœ ë¦¬í•œì§€ í™•ì‹ ì´ ì„œì§€ ì•Šì„ ê²½ìš°, ë‘˜ ë‹¤ í•´ë³´ê³  ë” ë‚˜ì€ ìª½ì„ ì„ íƒí•˜ê¸°!